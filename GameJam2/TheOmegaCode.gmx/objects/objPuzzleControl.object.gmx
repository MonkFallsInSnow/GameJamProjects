<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>puzzleCreated = false;
puzzleData = ds_grid_create(1,8);
checkDoor = false;

puzzleComplete = false;
andCircuitComplete = false;
xorCircuitComplete = false;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(room == rmTutorial ^^ room == rm1_0 ^^ room == rm2_0 ^^ room == rm3_0 ^^ room == rm4_0)
{
    //if the player is a certain distance from the door, then reset the atDoor variable to noone
    if(objPlayer.atDoor != noone)
    {
        with(objPlayer.atDoor)
        {
            if(point_distance(objPlayer.x,objPlayer.y,x,y) &gt;= 70)
            {
                objPlayer.atDoor = noone;
            }
        }
    }
}

//tutorial puzzle creation and solution
if(room == rmTutorial &amp;&amp; puzzleCreated == false)
{
    puzzleCreated = true;
    
    //puzzle initialization
    puzzleComplete = false;
    
    //create puzzle layout
    //tutorial circuit 1
    ds_grid_add(puzzleData,0,0,tutorialNode);
    ds_grid_add(puzzleData,0,1,tutorialNodePath1);
    ds_grid_add(puzzleData,0,2,tutorialNodePath2);
    ds_grid_add(puzzleData,0,3,tutorialNodePath3);
    ds_grid_add(puzzleData,0,4,tutorialNodePath4);
    ds_grid_add(puzzleData,0,5,tutorialNodePath5);
    ds_grid_add(puzzleData,0,6,tutorialNodePath6);
    ds_grid_add(puzzleData,0,7,tutorialNodePath7);
}  
//puzzle solution
else if (room == rmTutorial)
{ 
    //tutorial puzzle solution
    if(tutorialNode.on &amp;&amp; puzzleComplete == false) //correct solution
    {
        if(objPlayer.atDoor != noone)
        {
            puzzleComplete = true;
            exitDoor.locked = false;
            exitDoor.open = false;
            checkDoor = true;  
        }  
    }
    else if(tutorialNode.on == false &amp;&amp; puzzleComplete == true) //incorrect solution
    {
        if(objPlayer.atDoor != noone)
        {
            puzzleComplete = false;
            exitDoor.locked = true;
            exitDoor.open = true;
            checkDoor = true;
        }
    }  
}

//room 1 puzzle creation and solution
if(room == rm1_0 &amp;&amp; puzzleCreated == false) 
{
    ds_grid_clear(puzzleData,0);
    ds_grid_resize(puzzleData,5,20);
    
    puzzleCreated = true; 
    
    //puzzle initialization
    andCircuitComplete = false;
    xorCircuitComplete = false;
    puzzleComplete = false;
    
    //puzzle creation
    //create puzzle layout
    //and gate circuit 1
    ds_grid_add(puzzleData,0,0,andNode1);
    ds_grid_add(puzzleData,0,1,andNode1Path1);
    ds_grid_add(puzzleData,0,2,andNode1Path2);
    ds_grid_add(puzzleData,0,3,andNode1Path3);
    ds_grid_add(puzzleData,0,4,andNode1Path4);
    ds_grid_add(puzzleData,0,5,andNode1Path5);
    ds_grid_add(puzzleData,0,6,andNode1Path6);
    ds_grid_add(puzzleData,0,7,andNode1Path7);
    ds_grid_add(puzzleData,0,8,andNode1Path8);
    ds_grid_add(puzzleData,0,9,andNode1Path9);
    ds_grid_add(puzzleData,0,10,andNode1Path10);
    ds_grid_add(puzzleData,0,11,andNode1Path11);
    ds_grid_add(puzzleData,0,12,andNode1Path12);
    ds_grid_add(puzzleData,0,13,andNode1Path13);
    ds_grid_add(puzzleData,0,14,andNode1Path14);
    ds_grid_add(puzzleData,0,15,andNode1Path15);
    ds_grid_add(puzzleData,0,16,andNode1Path16);
    ds_grid_add(puzzleData,0,17,andNode1Path17);
    ds_grid_add(puzzleData,0,18,andNode1Path18);
    ds_grid_add(puzzleData,0,19,andNode1Path19);
    
    //and gate circuit 2
    ds_grid_add(puzzleData,1,0,andNode2);
    ds_grid_add(puzzleData,1,1,andNode2Path1);
    ds_grid_add(puzzleData,1,2,andNode2Path2);
    ds_grid_add(puzzleData,1,3,andNode2Path3);
    ds_grid_add(puzzleData,1,4,andNode2Path4);
    ds_grid_add(puzzleData,1,5,andNode2Path5);
    ds_grid_add(puzzleData,1,6,andNode2Path6);
    ds_grid_add(puzzleData,1,7,andNode2Path7);
    ds_grid_add(puzzleData,1,8,andNode2Path8);
    ds_grid_add(puzzleData,1,9,andNode2Path9);
    ds_grid_add(puzzleData,1,10,andNode2Path10);
    ds_grid_add(puzzleData,1,11,andNode2Path11);
    ds_grid_add(puzzleData,1,12,andNode2Path12);
    ds_grid_add(puzzleData,1,13,andNode2Path13);
    ds_grid_add(puzzleData,1,14,andNode2Path14);
    ds_grid_add(puzzleData,1,15,andNode2Path15);
    ds_grid_add(puzzleData,1,16,andNode2Path16);
    ds_grid_add(puzzleData,1,17,andNode2Path17);
    ds_grid_add(puzzleData,1,18,andNode2Path18);
    ds_grid_add(puzzleData,1,19,andNode2Path19);
    
    //xor gate circuit 1
    ds_grid_add(puzzleData,2,0,xorNode1);
    ds_grid_add(puzzleData,2,1,xorNode1Path1);
    ds_grid_add(puzzleData,2,2,xorNode1Path2);
    ds_grid_add(puzzleData,2,3,xorNode1Path3);
    ds_grid_add(puzzleData,2,4,xorNode1Path4);
    ds_grid_add(puzzleData,2,5,xorNode1Path5);
    ds_grid_add(puzzleData,2,6,xorNode1Path6);
    ds_grid_add(puzzleData,2,7,xorNode1Path7);
    ds_grid_add(puzzleData,2,8,xorNode1Path8);
    ds_grid_add(puzzleData,2,9,xorNode1Path9);
    ds_grid_add(puzzleData,2,10,xorNode1Path10);
    ds_grid_add(puzzleData,2,11,xorNode1Path11);
    ds_grid_add(puzzleData,2,12,xorNode1Path12);
    ds_grid_add(puzzleData,2,13,xorNode1Path13);
    ds_grid_add(puzzleData,2,14,xorNode1Path14);
    ds_grid_add(puzzleData,2,15,xorNode1Path15);
    ds_grid_add(puzzleData,2,16,xorNode1Path16);
    ds_grid_add(puzzleData,2,17,xorNode1Path17);
    
    //xor gate circuit 2
    ds_grid_add(puzzleData,3,0,xorNode2);
    ds_grid_add(puzzleData,3,1,xorNode2Path1);
    ds_grid_add(puzzleData,3,2,xorNode2Path2);
    ds_grid_add(puzzleData,3,3,xorNode2Path3);
    ds_grid_add(puzzleData,3,4,xorNode2Path4);
    ds_grid_add(puzzleData,3,5,xorNode2Path5);
    ds_grid_add(puzzleData,3,6,xorNode2Path6);
    ds_grid_add(puzzleData,3,7,xorNode2Path7);
    ds_grid_add(puzzleData,3,8,xorNode2Path8);
    ds_grid_add(puzzleData,3,9,xorNode2Path9);
    ds_grid_add(puzzleData,3,10,xorNode2Path10);
    ds_grid_add(puzzleData,3,11,xorNode2Path11);
    ds_grid_add(puzzleData,3,12,xorNode2Path12);
    ds_grid_add(puzzleData,3,13,xorNode2Path13);
    ds_grid_add(puzzleData,3,14,xorNode2Path14);
    ds_grid_add(puzzleData,3,15,xorNode2Path15);
    ds_grid_add(puzzleData,3,16,xorNode2Path16);
    ds_grid_add(puzzleData,3,17,xorNode2Path17);
    ds_grid_add(puzzleData,3,18,xorNode2Path18);
    
    //xor mini hub circit
    ds_grid_add(puzzleData,4,0,xorMiniHub);
    ds_grid_add(puzzleData,4,1,xorMiniHubPath1);
    ds_grid_add(puzzleData,4,2,xorMiniHubPath2);
    ds_grid_add(puzzleData,4,3,xorMiniHubPath3);
    ds_grid_add(puzzleData,4,4,xorMiniHubPath4);
    ds_grid_add(puzzleData,4,5,xorMiniHubPath5);
    ds_grid_add(puzzleData,4,6,xorMiniHubPath6);
    ds_grid_add(puzzleData,4,7,xorMiniHubPath7);
    ds_grid_add(puzzleData,4,8,xorMiniHubPath8);
    ds_grid_add(puzzleData,4,9,xorMiniHubPath9);
    
} 
//puzzle solution
else if (room == rm1_0)
{   
    //if and node gate is complete, then open first door
    if(andNode1.on &amp;&amp; andNode2.on &amp;&amp; andCircuitComplete == false)
    {   
        if(objPlayer.atDoor == andDoor1)
        {
            andCircuitComplete = true;
            andDoor1.locked = false;
            andDoor1.open = false;
            checkDoor = true;
        }
    }
    else if((andNode1.on == false || andNode2.on == false) &amp;&amp; andCircuitComplete == true) 
    {
        if(objPlayer.atDoor == andDoor1)
        {
            andCircuitComplete = false;
            andDoor1.locked = true;
            andDoor1.open = true;
            checkDoor = true;
        }
    }
    
    //if the xor node gate is complete, then turn on the xor mini hub
    if((xorNode1.on ^^ xorNode2.on) &amp;&amp; xorCircuitComplete == false)
    {       
        activateNode(objPuzzleControl.puzzleData,xorMiniHub);
        
        xorCircuitComplete = true;
    }
    else if(((xorNode1.on == false &amp;&amp; xorNode2.on == false) ^^ (xorNode1.on == true &amp;&amp; xorNode2.on == true)) &amp;&amp; xorCircuitComplete == true) 
    {
        activateNode(objPuzzleControl.puzzleData,xorMiniHub);
        
        xorCircuitComplete = false;
    }

    //if the puzzle is solved, then open the door
    if(xorMiniHub.on &amp;&amp; puzzleComplete == false)
    {
        if(objPlayer.atDoor == exitDoor)
        {
            puzzleComplete = true;
            exitDoor.locked = false;
            exitDoor.open = false;
            checkDoor = true;
        }

    }
    else if(xorMiniHub.on == false &amp;&amp; puzzleComplete = true)
    {
        if(objPlayer.atDoor == exitDoor)
        {
            puzzleComplete = false;
            exitDoor.locked = true;
            exitDoor.open = true;
            checkDoor = true;
        }
    }
}

//room 2 creation and solution
if(room == rm2_0 &amp;&amp; puzzleCreated == false) 
{
    ds_grid_clear(puzzleData,0);
    ds_grid_resize(puzzleData,7,52); //replace with actual values...
    
    puzzleCreated = true; 
    
    //puzzle initialization
    xorCircuitCompleteR2 = false;
    andCircuitCompleteR2 = false;
    upgradeCircuitCompleteR2 = false;
    leftNodeCircuitCompleteR2 = false;
    rightNodeCircuitCompleteR2 = false;
    puzzleComplete = false;
    
    //puzzle creation
    //xor gate 1 circuit 1
    ds_grid_add(puzzleData,0,0,xorNode1R2);
    ds_grid_add(puzzleData,0,1,xorNode1Path1R2);
    ds_grid_add(puzzleData,0,2,xorNode1Path2R2);
    ds_grid_add(puzzleData,0,3,xorNode1Path3R2);
    ds_grid_add(puzzleData,0,4,xorNode1Path4R2);
    ds_grid_add(puzzleData,0,5,xorNode1Path5R2);
    ds_grid_add(puzzleData,0,6,xorNode1Path6R2);
    ds_grid_add(puzzleData,0,7,xorNode1Path7R2);
    ds_grid_add(puzzleData,0,8,xorNode1Path8R2);
    ds_grid_add(puzzleData,0,9,xorNode1Path9R2);
    ds_grid_add(puzzleData,0,10,xorNode1Path10R2);
    ds_grid_add(puzzleData,0,11,xorNode1Path11R2);
    ds_grid_add(puzzleData,0,12,xorNode1Path12R2);
    ds_grid_add(puzzleData,0,13,xorNode1Path13R2);
    ds_grid_add(puzzleData,0,14,xorNode1Path14R2);
    ds_grid_add(puzzleData,0,15,xorNode1Path15R2);
    ds_grid_add(puzzleData,0,16,xorNode1Path16R2);
    ds_grid_add(puzzleData,0,17,xorNode1Path17R2);
    ds_grid_add(puzzleData,0,18,xorNode1Path18R2);
    ds_grid_add(puzzleData,0,19,xorNode1Path19R2);
    ds_grid_add(puzzleData,0,20,xorNode1Path20R2);
    ds_grid_add(puzzleData,0,21,xorNode1Path21R2);
    ds_grid_add(puzzleData,0,22,xorNode1Path22R2);
    ds_grid_add(puzzleData,0,23,xorNode1Path23R2);
    ds_grid_add(puzzleData,0,24,xorNode1Path24R2);
    
    //xor gate 1 circuit 2
    ds_grid_add(puzzleData,1,0,xorNode2R2);
    ds_grid_add(puzzleData,1,1,xorNode2Path1R2);
    ds_grid_add(puzzleData,1,2,xorNode2Path2R2);
    ds_grid_add(puzzleData,1,3,xorNode2Path3R2);
    ds_grid_add(puzzleData,1,4,xorNode2Path4R2);
    ds_grid_add(puzzleData,1,5,xorNode2Path5R2);
    ds_grid_add(puzzleData,1,6,xorNode2Path6R2);
    ds_grid_add(puzzleData,1,7,xorNode2Path7R2);
    ds_grid_add(puzzleData,1,8,xorNode2Path8R2);
    ds_grid_add(puzzleData,1,9,xorNode2Path9R2);
    ds_grid_add(puzzleData,1,10,xorNode2Path10R2);
    ds_grid_add(puzzleData,1,11,xorNode2Path11R2);
    ds_grid_add(puzzleData,1,12,xorNode2Path12R2);
    ds_grid_add(puzzleData,1,13,xorNode2Path13R2);
    ds_grid_add(puzzleData,1,14,xorNode2Path14R2);
    ds_grid_add(puzzleData,1,15,xorNode2Path15R2);
    ds_grid_add(puzzleData,1,16,xorNode2Path16R2);
    ds_grid_add(puzzleData,1,17,xorNode2Path17R2);
    ds_grid_add(puzzleData,1,18,xorNode2Path18R2);
    ds_grid_add(puzzleData,1,19,xorNode2Path19R2);
    ds_grid_add(puzzleData,1,20,xorNode2Path20R2);
    ds_grid_add(puzzleData,1,21,xorNode2Path21R2);
    ds_grid_add(puzzleData,1,22,xorNode2Path22R2);
    
    //and gate 1 circuit 1
    ds_grid_add(puzzleData,2,0,andNode1R2);
    ds_grid_add(puzzleData,2,1,andNode1Path1R2);
    ds_grid_add(puzzleData,2,2,andNode1Path2R2);
    ds_grid_add(puzzleData,2,3,andNode1Path3R2);
    ds_grid_add(puzzleData,2,4,andNode1Path4R2);
    ds_grid_add(puzzleData,2,5,andNode1Path5R2);
    ds_grid_add(puzzleData,2,6,andNode1Path6R2);
    ds_grid_add(puzzleData,2,7,andNode1Path7R2);
    ds_grid_add(puzzleData,2,8,andNode1Path8R2);
    ds_grid_add(puzzleData,2,9,andNode1Path9R2);
    ds_grid_add(puzzleData,2,10,andNode1Path10R2);
    ds_grid_add(puzzleData,2,11,andNode1Path11R2);
    ds_grid_add(puzzleData,2,12,andNode1Path12R2);
    ds_grid_add(puzzleData,2,13,andNode1Path13R2);
    ds_grid_add(puzzleData,2,14,andNode1Path14R2);
    ds_grid_add(puzzleData,2,15,andNode1Path15R2);
    ds_grid_add(puzzleData,2,16,andNode1Path16R2);
    ds_grid_add(puzzleData,2,17,andNode1Path17R2);
    ds_grid_add(puzzleData,2,18,andNode1Path18R2);
    ds_grid_add(puzzleData,2,19,andNode1Path19R2);
    ds_grid_add(puzzleData,2,20,andNode1Path20R2);
    ds_grid_add(puzzleData,2,21,andNode1Path21R2);
    ds_grid_add(puzzleData,2,22,andNode1Path22R2);
    ds_grid_add(puzzleData,2,23,andNode1Path23R2);
    ds_grid_add(puzzleData,2,24,andNode1Path24R2);
    ds_grid_add(puzzleData,2,25,andNode1Path25R2);
    ds_grid_add(puzzleData,2,26,andNode1Path26R2);
    ds_grid_add(puzzleData,2,27,andNode1Path27R2);
    ds_grid_add(puzzleData,2,28,andNode1Path28R2);
    ds_grid_add(puzzleData,2,29,andNode1Path29R2);
    ds_grid_add(puzzleData,2,30,andNode1Path30R2);
    ds_grid_add(puzzleData,2,31,andNode1Path31R2);
    ds_grid_add(puzzleData,2,32,andNode1Path32R2);
    ds_grid_add(puzzleData,2,33,andNode1Path33R2);
    ds_grid_add(puzzleData,2,34,andNode1Path34R2);
    ds_grid_add(puzzleData,2,35,andNode1Path35R2);
    ds_grid_add(puzzleData,2,36,andNode1Path36R2);
    ds_grid_add(puzzleData,2,37,andNode1Path37R2);
    ds_grid_add(puzzleData,2,38,andNode1Path38R2);
    
    //and gate 1 circuit 2
    ds_grid_add(puzzleData,3,0,andNode2R2);
    ds_grid_add(puzzleData,3,1,andNode2Path1R2);
    ds_grid_add(puzzleData,3,2,andNode2Path2R2);
    ds_grid_add(puzzleData,3,3,andNode2Path3R2);
    ds_grid_add(puzzleData,3,4,andNode2Path4R2);
    ds_grid_add(puzzleData,3,5,andNode2Path5R2);
    ds_grid_add(puzzleData,3,6,andNode2Path6R2);
    ds_grid_add(puzzleData,3,7,andNode2Path7R2);
    ds_grid_add(puzzleData,3,8,andNode2Path8R2);
    ds_grid_add(puzzleData,3,9,andNode2Path9R2);
    ds_grid_add(puzzleData,3,10,andNode2Path10R2);
    ds_grid_add(puzzleData,3,11,andNode2Path11R2);
    ds_grid_add(puzzleData,3,12,andNode2Path12R2);
    ds_grid_add(puzzleData,3,13,andNode2Path13R2);
    ds_grid_add(puzzleData,3,14,andNode2Path14R2);
    ds_grid_add(puzzleData,3,15,andNode2Path15R2);
    ds_grid_add(puzzleData,3,16,andNode2Path16R2);
    ds_grid_add(puzzleData,3,17,andNode2Path17R2);
    ds_grid_add(puzzleData,3,18,andNode2Path18R2);
    ds_grid_add(puzzleData,3,19,andNode2Path19R2);
    ds_grid_add(puzzleData,3,20,andNode2Path20R2);
    ds_grid_add(puzzleData,3,21,andNode2Path21R2);
    ds_grid_add(puzzleData,3,22,andNode2Path22R2);
    ds_grid_add(puzzleData,3,23,andNode2Path23R2);
    ds_grid_add(puzzleData,3,24,andNode2Path24R2);
    ds_grid_add(puzzleData,3,25,andNode2Path25R2);
    ds_grid_add(puzzleData,3,26,andNode2Path26R2);
    ds_grid_add(puzzleData,3,27,andNode2Path27R2);
    ds_grid_add(puzzleData,3,28,andNode2Path28R2);
    ds_grid_add(puzzleData,3,29,andNode2Path29R2);
    ds_grid_add(puzzleData,3,30,andNode2Path30R2);
    ds_grid_add(puzzleData,3,31,andNode2Path31R2);
    ds_grid_add(puzzleData,3,32,andNode2Path32R2);
    ds_grid_add(puzzleData,3,33,andNode2Path33R2);
    ds_grid_add(puzzleData,3,34,andNode2Path34R2);
    ds_grid_add(puzzleData,3,35,andNode2Path35R2);
    
    //upgrade terminal room circuit
    ds_grid_add(puzzleData,4,0,upgradeNodeR2);
    ds_grid_add(puzzleData,4,1,upgradeNodePath1R2);
    ds_grid_add(puzzleData,4,2,upgradeNodePath2R2);
    ds_grid_add(puzzleData,4,3,upgradeNodePath3R2);
    ds_grid_add(puzzleData,4,4,upgradeNodePath4R2);
    ds_grid_add(puzzleData,4,5,upgradeNodePath5R2);
    ds_grid_add(puzzleData,4,6,upgradeNodePath6R2);
    ds_grid_add(puzzleData,4,7,upgradeNodePath7R2);
    ds_grid_add(puzzleData,4,8,upgradeNodePath8R2);
    ds_grid_add(puzzleData,4,9,upgradeNodePath9R2);
    ds_grid_add(puzzleData,4,10,upgradeNodePath10R2);
    ds_grid_add(puzzleData,4,11,upgradeNodePath11R2);
    ds_grid_add(puzzleData,4,12,upgradeNodePath12R2);
    ds_grid_add(puzzleData,4,13,upgradeNodePath13R2);
    ds_grid_add(puzzleData,4,14,upgradeNodePath14R2);
    ds_grid_add(puzzleData,4,15,upgradeNodePath15R2);
    ds_grid_add(puzzleData,4,16,upgradeNodePath16R2);
    ds_grid_add(puzzleData,4,17,upgradeNodePath17R2);
    ds_grid_add(puzzleData,4,18,upgradeNodePath18R2);
    ds_grid_add(puzzleData,4,19,upgradeNodePath19R2);
    ds_grid_add(puzzleData,4,20,upgradeNodePath20R2);
    ds_grid_add(puzzleData,4,21,upgradeNodePath21R2);
    ds_grid_add(puzzleData,4,22,upgradeNodePath22R2);
    ds_grid_add(puzzleData,4,23,upgradeNodePath23R2);
    ds_grid_add(puzzleData,4,24,upgradeNodePath24R2);
    ds_grid_add(puzzleData,4,25,upgradeNodePath25R2);
    ds_grid_add(puzzleData,4,26,upgradeNodePath26R2);
    ds_grid_add(puzzleData,4,27,upgradeNodePath27R2);
    ds_grid_add(puzzleData,4,28,upgradeNodePath28R2);
    ds_grid_add(puzzleData,4,29,upgradeNodePath29R2);
    ds_grid_add(puzzleData,4,30,upgradeNodePath30R2);
    ds_grid_add(puzzleData,4,31,upgradeNodePath31R2);
    ds_grid_add(puzzleData,4,32,upgradeNodePath32R2);
    ds_grid_add(puzzleData,4,33,upgradeNodePath33R2);
    ds_grid_add(puzzleData,4,34,upgradeNodePath34R2);
    ds_grid_add(puzzleData,4,35,upgradeNodePath35R2);
    ds_grid_add(puzzleData,4,36,upgradeNodePath36R2);
    ds_grid_add(puzzleData,4,37,upgradeNodePath37R2);
    ds_grid_add(puzzleData,4,38,upgradeNodePath38R2);
    ds_grid_add(puzzleData,4,39,upgradeNodePath39R2);
    ds_grid_add(puzzleData,4,40,upgradeNodePath40R2);
    ds_grid_add(puzzleData,4,41,upgradeNodePath41R2);
    ds_grid_add(puzzleData,4,42,upgradeNodePath42R2);
    ds_grid_add(puzzleData,4,43,upgradeNodePath43R2);
    ds_grid_add(puzzleData,4,44,upgradeNodePath44R2);
    
    //left node circuit (upper half of map)
    ds_grid_add(puzzleData,5,0,leftNodeR2);
    ds_grid_add(puzzleData,5,1,leftNodePath1R2);
    ds_grid_add(puzzleData,5,2,leftNodePath2R2);
    ds_grid_add(puzzleData,5,3,leftNodePath3R2);
    ds_grid_add(puzzleData,5,4,leftNodePath4R2);
    ds_grid_add(puzzleData,5,5,leftNodePath5R2);
    ds_grid_add(puzzleData,5,6,leftNodePath6R2);
    ds_grid_add(puzzleData,5,7,leftNodePath7R2);
    ds_grid_add(puzzleData,5,8,leftNodePath8R2);
    ds_grid_add(puzzleData,5,9,leftNodePath9R2);
    ds_grid_add(puzzleData,5,10,leftNodePath10R2);
    ds_grid_add(puzzleData,5,11,leftNodePath11R2);
    ds_grid_add(puzzleData,5,12,leftNodePath12R2);
    ds_grid_add(puzzleData,5,13,leftNodePath13R2);
    ds_grid_add(puzzleData,5,14,leftNodePath14R2);
    ds_grid_add(puzzleData,5,15,leftNodePath15R2);
    ds_grid_add(puzzleData,5,16,leftNodePath16R2);
    ds_grid_add(puzzleData,5,17,leftNodePath17R2);
    ds_grid_add(puzzleData,5,18,leftNodePath18R2);
    ds_grid_add(puzzleData,5,19,leftNodePath19R2);
    ds_grid_add(puzzleData,5,20,leftNodePath20R2);
    ds_grid_add(puzzleData,5,21,leftNodePath21R2);
    ds_grid_add(puzzleData,5,22,leftNodePath22R2);
    ds_grid_add(puzzleData,5,23,leftNodePath23R2);
    ds_grid_add(puzzleData,5,24,leftNodePath24R2);
    ds_grid_add(puzzleData,5,25,leftNodePath25R2);
    ds_grid_add(puzzleData,5,26,leftNodePath26R2);
    ds_grid_add(puzzleData,5,27,leftNodePath27R2); 
    ds_grid_add(puzzleData,5,28,leftNodePath28R2);
    ds_grid_add(puzzleData,5,29,leftNodePath29R2);
    ds_grid_add(puzzleData,5,30,leftNodePath30R2);
    ds_grid_add(puzzleData,5,31,leftNodePath31R2);
    ds_grid_add(puzzleData,5,32,leftNodePath32R2);
    ds_grid_add(puzzleData,5,33,leftNodePath33R2);
    ds_grid_add(puzzleData,5,34,leftNodePath34R2);
    ds_grid_add(puzzleData,5,35,leftNodePath35R2);
    ds_grid_add(puzzleData,5,36,leftNodePath36R2);
    ds_grid_add(puzzleData,5,37,leftNodePath37R2); 
    ds_grid_add(puzzleData,5,38,leftNodePath38R2);
    ds_grid_add(puzzleData,5,39,leftNodePath39R2);
    ds_grid_add(puzzleData,5,40,leftNodePath40R2);
    ds_grid_add(puzzleData,5,41,leftNodePath41R2);
    ds_grid_add(puzzleData,5,42,leftNodePath42R2);
    ds_grid_add(puzzleData,5,43,leftNodePath43R2);
    ds_grid_add(puzzleData,5,44,leftNodePath44R2);
    ds_grid_add(puzzleData,5,45,leftNodePath45R2);
    ds_grid_add(puzzleData,5,46,leftNodePath46R2);
    ds_grid_add(puzzleData,5,47,leftNodePath47R2);
    
    //right node circuit (upper half of map)
    ds_grid_add(puzzleData,6,0,rightNodeR2);
    ds_grid_add(puzzleData,6,1,rightNodePath1R2);
    ds_grid_add(puzzleData,6,2,rightNodePath2R2);
    ds_grid_add(puzzleData,6,3,rightNodePath3R2);
    ds_grid_add(puzzleData,6,4,rightNodePath4R2);
    ds_grid_add(puzzleData,6,5,rightNodePath5R2);
    ds_grid_add(puzzleData,6,6,rightNodePath6R2);
    ds_grid_add(puzzleData,6,7,rightNodePath7R2);
    ds_grid_add(puzzleData,6,8,rightNodePath8R2);
    ds_grid_add(puzzleData,6,9,rightNodePath9R2);
    ds_grid_add(puzzleData,6,10,rightNodePath10R2);
    ds_grid_add(puzzleData,6,11,rightNodePath11R2);
    ds_grid_add(puzzleData,6,12,rightNodePath12R2);
    ds_grid_add(puzzleData,6,13,rightNodePath13R2);
    ds_grid_add(puzzleData,6,14,rightNodePath14R2);
    ds_grid_add(puzzleData,6,15,rightNodePath15R2);
    ds_grid_add(puzzleData,6,16,rightNodePath16R2);
    ds_grid_add(puzzleData,6,17,rightNodePath17R2);
    ds_grid_add(puzzleData,6,18,rightNodePath18R2);
    ds_grid_add(puzzleData,6,19,rightNodePath19R2);
    ds_grid_add(puzzleData,6,20,rightNodePath20R2);
    ds_grid_add(puzzleData,6,21,rightNodePath21R2);
    ds_grid_add(puzzleData,6,22,rightNodePath22R2);
    ds_grid_add(puzzleData,6,23,rightNodePath23R2);
    ds_grid_add(puzzleData,6,24,rightNodePath24R2);
    ds_grid_add(puzzleData,6,25,rightNodePath25R2);
    ds_grid_add(puzzleData,6,26,rightNodePath26R2);
    ds_grid_add(puzzleData,6,27,rightNodePath27R2);
    ds_grid_add(puzzleData,6,28,rightNodePath28R2);
    ds_grid_add(puzzleData,6,29,rightNodePath29R2);
    ds_grid_add(puzzleData,6,30,rightNodePath30R2);
    ds_grid_add(puzzleData,6,31,rightNodePath31R2);
    ds_grid_add(puzzleData,6,32,rightNodePath32R2);
    ds_grid_add(puzzleData,6,33,rightNodePath33R2);
    ds_grid_add(puzzleData,6,34,rightNodePath34R2);
    ds_grid_add(puzzleData,6,35,rightNodePath35R2);
    ds_grid_add(puzzleData,6,36,rightNodePath36R2);
    ds_grid_add(puzzleData,6,37,rightNodePath37R2);
    ds_grid_add(puzzleData,6,38,rightNodePath38R2);
    ds_grid_add(puzzleData,6,39,rightNodePath39R2);
    ds_grid_add(puzzleData,6,40,rightNodePath40R2);
    ds_grid_add(puzzleData,6,41,rightNodePath41R2);
    ds_grid_add(puzzleData,6,42,rightNodePath42R2);
    ds_grid_add(puzzleData,6,43,rightNodePath43R2);
    ds_grid_add(puzzleData,6,44,rightNodePath44R2);
    ds_grid_add(puzzleData,6,45,rightNodePath45R2);
    ds_grid_add(puzzleData,6,46,rightNodePath46R2);
    ds_grid_add(puzzleData,6,47,rightNodePath47R2);
    ds_grid_add(puzzleData,6,48,rightNodePath48R2);
    ds_grid_add(puzzleData,6,49,rightNodePath49R2);
    ds_grid_add(puzzleData,6,50,rightNodePath50R2);
    ds_grid_add(puzzleData,6,51,rightNodePath51R2);
    
}
else if (room == rm2_0)
{
    //if the xor gate 1 is complete, then unlock the first door
    if((xorNode1R2.on ^^ xorNode2R2.on) &amp;&amp; xorCircuitCompleteR2 == false)
    {
        if(objPlayer.atDoor == xorDoor1R2)
        {
            xorCircuitCompleteR2 = true;
            xorDoor1R2.locked = false;
            xorDoor1R2.open = false;
            checkDoor = true;
        }
    }
    else if((xorNode1R2.on &amp;&amp; xorNode2R2.on) ^^ (xorNode1R2.on == false &amp;&amp; xorNode2R2.on == false) &amp;&amp; xorCircuitCompleteR2 == true)
    {
        if(objPlayer.atDoor == xorDoor1R2)
        {
            xorCircuitCompleteR2 = false;
            xorDoor1R2.locked = true;
            xorDoor1R2.open = true;
            checkDoor = true;
        }
    }
    
    //if the and gate 1 is complete, then unlock the second door
    if(andNode1R2.on &amp;&amp; andNode2R2.on &amp;&amp; andCircuitCompleteR2 == false)
    {
        if(objPlayer.atDoor == andDoor1R2)
        {
            andCircuitCompleteR2 = true;
            andDoor1R2.locked = false;
            andDoor1R2.open = false;
            checkDoor = true;
        }
    }
    else if((andNode1R2.on == false || andNode2R2.on == false) &amp;&amp; andCircuitCompleteR2 == true) 
    {
        if(objPlayer.atDoor == andDoor1R2)
        {
            andCircuitCompleteR2 = false;
            andDoor1R2.locked = true;
            andDoor1R2.open = true;
            checkDoor = true;
        }
    }
    
    //if upgrade terminal room is unlocked
    if((xorNode1R2.on ^^ xorNode2R2.on) &amp;&amp; (andNode1R2.on &amp;&amp; andNode2R2.on) &amp;&amp; upgradeNodeR2.on &amp;&amp; upgradeCircuitCompleteR2 == false)
    {   
        if(objPlayer.atDoor == upgradeDoor1)
        {   
            upgradeCircuitCompleteR2 = true;
            upgradeDoor1.locked = false;
            upgradeDoor1.open = false;
            checkDoor = true;
        } 
    }
    else if((((xorNode1R2.on &amp;&amp; xorNode2R2.on) ^^ (xorNode1R2.on == false &amp;&amp; xorNode2R2.on == false)) || (andNode1R2.on == false || andNode2R2.on == false)) &amp;&amp; upgradeCircuitCompleteR2 == true)
    {
        if(objPlayer.atDoor == upgradeDoor1)
        {
            upgradeCircuitCompleteR2 = false;
            upgradeDoor1.locked = true;
            upgradeDoor1.open = true;
            checkDoor = true;
        }
    }
    
    //if left door is unlocked
    if(leftNodeR2.on &amp;&amp; leftNodeCircuitCompleteR2 == false)
    {
        if(objPlayer.atDoor == leftDoor)
        {   
            activateNode(puzzleData,andNode1R2);
            andCircuitCompleteR2 = true;
            leftNodeCircuitCompleteR2 = true;
            leftDoor.locked = false;
            leftDoor.open = false;
            checkDoor = true;
        }
    }
    else if(leftNodeR2.on == false &amp;&amp; leftNodeCircuitCompleteR2)
    {
        if(objPlayer.atDoor == leftDoor)
        {   
            activateNode(puzzleData,andNode1R2);
            andCircuitCompleteR2 = false;
            leftNodeCircuitCompleteR2 = false;
            leftDoor.locked = true;
            leftDoor.open = true;
            checkDoor = true;
        }
    }
    
    //if right door is unlocked
    if(rightNodeR2.on &amp;&amp; rightNodeCircuitCompleteR2 == false)
    {
        if(objPlayer.atDoor == rightDoor)
        {   
            activateNode(puzzleData,andNode2R2);
            andCircuitCompleteR2 = true;
            rightNodeCircuitCompleteR2 = true;
            rightDoor.locked = false;
            rightDoor.open = false;
            checkDoor = true;
        }
    }
    else if(rightNodeR2.on == false &amp;&amp; rightNodeCircuitCompleteR2)
    {
        if(objPlayer.atDoor == rightDoor)
        {   
            activateNode(puzzleData,andNode2R2);
            andCircuitCompleteR2 = false;
            rightNodeCircuitCompleteR2 = false;
            rightDoor.locked = true;
            rightDoor.open = true;
            checkDoor = true;
        }
    }
    
    //if the puzzle is solved, then open the final door
    if(leftNodeR2.on &amp;&amp; rightNodeR2.on &amp;&amp; puzzleComplete == false)
    {
        if(objPlayer.atDoor == exitDoor)
        {
            puzzleComplete = true;
            exitDoor.locked = false;
            exitDoor.open = false;
            checkDoor = true;
        }

    }
    else if((leftNodeR2.on == false || rightNodeR2.on == false) &amp;&amp; puzzleComplete = true)
    {
        if(objPlayer.atDoor == exitDoor)
        {
            puzzleComplete = false;
            exitDoor.locked = true;
            exitDoor.open = true;
            checkDoor = true;
        }
    }
    
}

//room 3 creation and solution
if(room == rm3_0 &amp;&amp; puzzleCreated == false) 
{
    ds_grid_clear(puzzleData,0);
    ds_grid_resize(puzzleData,5,38);
    
    puzzleCreated = true; 
    
    //puzzle initialization
    puzzleComplete1 = false;
    puzzleComplete2 = false;
    node1CircuitCompleteR3 = false;
    andCircuit1CompleteR3 = false;
    andCircuit2CompleteR3 = false;
    
    //node 1 circiut
    ds_grid_add(puzzleData,0,0,node1R3);
    ds_grid_add(puzzleData,0,1,node1Path1R3);
    ds_grid_add(puzzleData,0,2,node1Path2R3);
    ds_grid_add(puzzleData,0,3,node1Path3R3);
    ds_grid_add(puzzleData,0,4,node1Path4R3);
    ds_grid_add(puzzleData,0,5,node1Path5R3);
    ds_grid_add(puzzleData,0,6,node1Path6R3);
    ds_grid_add(puzzleData,0,7,node1Path7R3);
    ds_grid_add(puzzleData,0,8,node1Path8R3);
    ds_grid_add(puzzleData,0,9,node1Path9R3);
    ds_grid_add(puzzleData,0,10,node1Path10R3);
    ds_grid_add(puzzleData,0,11,node1Path11R3);
    ds_grid_add(puzzleData,0,12,node1Path12R3);
    ds_grid_add(puzzleData,0,13,node1Path13R3);
    ds_grid_add(puzzleData,0,14,node1Path14R3);
    ds_grid_add(puzzleData,0,15,node1Path15R3);
    ds_grid_add(puzzleData,0,16,node1Path16R3);
    ds_grid_add(puzzleData,0,17,node1Path17R3);
    ds_grid_add(puzzleData,0,18,node1Path18R3);
    ds_grid_add(puzzleData,0,19,node1Path19R3);
    ds_grid_add(puzzleData,0,20,node1Path20R3);
    ds_grid_add(puzzleData,0,21,node1Path21R3);
    
    //node 2 circiut
    ds_grid_add(puzzleData,1,0,node2R3);
    ds_grid_add(puzzleData,1,1,node2Path1R3);
    ds_grid_add(puzzleData,1,2,node2Path2R3);
    ds_grid_add(puzzleData,1,3,node2Path3R3);
    ds_grid_add(puzzleData,1,4,node2Path4R3);
    ds_grid_add(puzzleData,1,5,node2Path5R3);
    ds_grid_add(puzzleData,1,6,node2Path6R3);
    ds_grid_add(puzzleData,1,7,node2Path7R3);
    ds_grid_add(puzzleData,1,8,node2Path8R3);
    ds_grid_add(puzzleData,1,9,node2Path9R3);
    ds_grid_add(puzzleData,1,10,node2Path10R3);
    ds_grid_add(puzzleData,1,11,node2Path11R3);
    ds_grid_add(puzzleData,1,12,node2Path12R3);
    ds_grid_add(puzzleData,1,13,node2Path13R3);
    ds_grid_add(puzzleData,1,14,node2Path14R3);
    ds_grid_add(puzzleData,1,15,node2Path15R3);
    ds_grid_add(puzzleData,1,16,node2Path16R3);
    ds_grid_add(puzzleData,1,17,node2Path17R3);
    ds_grid_add(puzzleData,1,18,node2Path18R3);
    ds_grid_add(puzzleData,1,19,node2Path19R3);
    ds_grid_add(puzzleData,1,20,node2Path20R3);
    ds_grid_add(puzzleData,1,21,node2Path21R3);
    ds_grid_add(puzzleData,1,22,node2Path22R3);
    ds_grid_add(puzzleData,1,23,node2Path23R3);
    ds_grid_add(puzzleData,1,24,node2Path24R3);
    ds_grid_add(puzzleData,1,25,node2Path25R3);
    ds_grid_add(puzzleData,1,26,node2Path26R3);
    ds_grid_add(puzzleData,1,27,node2Path27R3);
    ds_grid_add(puzzleData,1,28,node2Path28R3);
    ds_grid_add(puzzleData,1,29,node2Path29R3);
    ds_grid_add(puzzleData,1,30,node2Path30R3);
    ds_grid_add(puzzleData,1,31,node2Path31R3);
    ds_grid_add(puzzleData,1,32,node2Path32R3);
    ds_grid_add(puzzleData,1,33,node2Path33R3);
    ds_grid_add(puzzleData,1,34,node2Path34R3);
    ds_grid_add(puzzleData,1,35,node2Path35R3);
    ds_grid_add(puzzleData,1,36,node2Path36R3);
    ds_grid_add(puzzleData,1,37,node2Path37R3);
    
    //node 3 circuit
    ds_grid_add(puzzleData,2,0,node3R3);
    ds_grid_add(puzzleData,2,1,node3Path1R3);
    ds_grid_add(puzzleData,2,2,node3Path2R3);
    ds_grid_add(puzzleData,2,3,node3Path3R3);
    ds_grid_add(puzzleData,2,4,node3Path4R3);
    ds_grid_add(puzzleData,2,5,node3Path5R3);
    ds_grid_add(puzzleData,2,6,node3Path6R3);
    ds_grid_add(puzzleData,2,7,node3Path7R3);
    ds_grid_add(puzzleData,2,8,node3Path8R3);
    ds_grid_add(puzzleData,2,9,node3Path9R3);
    ds_grid_add(puzzleData,2,10,node3Path10R3);
    ds_grid_add(puzzleData,2,11,node3Path11R3);
    ds_grid_add(puzzleData,2,12,node3Path12R3);
    ds_grid_add(puzzleData,2,13,node3Path13R3);
    ds_grid_add(puzzleData,2,14,node3Path14R3);
    ds_grid_add(puzzleData,2,15,node3Path15R3);
    ds_grid_add(puzzleData,2,16,node3Path16R3);
    ds_grid_add(puzzleData,2,17,node3Path17R3);
    
    //node 4 circuit
    ds_grid_add(puzzleData,3,0,node4R3);
    ds_grid_add(puzzleData,3,1,node4Path1R3);
    ds_grid_add(puzzleData,3,2,node4Path2R3);
    ds_grid_add(puzzleData,3,3,node4Path3R3);
    ds_grid_add(puzzleData,3,4,node4Path4R3);
    ds_grid_add(puzzleData,3,5,node4Path5R3);
    ds_grid_add(puzzleData,3,6,node4Path6R3);
    ds_grid_add(puzzleData,3,7,node4Path7R3);
    ds_grid_add(puzzleData,3,8,node4Path8R3);
    ds_grid_add(puzzleData,3,9,node4Path9R3);
    ds_grid_add(puzzleData,3,10,node4Path10R3);
    ds_grid_add(puzzleData,3,11,node4Path11R3);
    ds_grid_add(puzzleData,3,12,node4Path12R3);
    ds_grid_add(puzzleData,3,13,node4Path13R3);
    ds_grid_add(puzzleData,3,14,node4Path14R3);
    ds_grid_add(puzzleData,3,15,node4Path15R3);
    ds_grid_add(puzzleData,3,16,node4Path16R3);
    ds_grid_add(puzzleData,3,17,node4Path17R3);
    ds_grid_add(puzzleData,3,18,node4Path18R3);
    ds_grid_add(puzzleData,3,19,node4Path19R3);
    ds_grid_add(puzzleData,3,20,node4Path20R3);
    ds_grid_add(puzzleData,3,21,node4Path21R3);
    ds_grid_add(puzzleData,3,22,node4Path22R3);
    ds_grid_add(puzzleData,3,23,node4Path23R3);
    ds_grid_add(puzzleData,3,24,node4Path24R3);
    ds_grid_add(puzzleData,3,25,node4Path25R3);
    ds_grid_add(puzzleData,3,26,node4Path26R3);
    ds_grid_add(puzzleData,3,27,node4Path27R3);
    ds_grid_add(puzzleData,3,28,node4Path28R3);
    ds_grid_add(puzzleData,3,29,node4Path29R3);
    ds_grid_add(puzzleData,3,30,node4Path30R3);
    ds_grid_add(puzzleData,3,31,node4Path31R3);
    ds_grid_add(puzzleData,3,32,node4Path32R3);
    ds_grid_add(puzzleData,3,33,node4Path33R3);
    
    //node 5
    ds_grid_add(puzzleData,4,0,node5R3);
    ds_grid_add(puzzleData,4,1,node5Path1R3);
    ds_grid_add(puzzleData,4,2,node5Path2R3);
    ds_grid_add(puzzleData,4,3,node5Path3R3);
    ds_grid_add(puzzleData,4,4,node5Path4R3);
    ds_grid_add(puzzleData,4,5,node5Path5R3);
    ds_grid_add(puzzleData,4,6,node5Path6R3);
    ds_grid_add(puzzleData,4,7,node5Path7R3);
    ds_grid_add(puzzleData,4,8,node5Path8R3);
    ds_grid_add(puzzleData,4,9,node5Path9R3);
    ds_grid_add(puzzleData,4,10,node5Path10R3);
    ds_grid_add(puzzleData,4,11,node5Path11R3);
    ds_grid_add(puzzleData,4,12,node5Path12R3);
    ds_grid_add(puzzleData,4,13,node5Path13R3);
    ds_grid_add(puzzleData,4,14,node5Path14R3);
    ds_grid_add(puzzleData,4,15,node5Path15R3);
    ds_grid_add(puzzleData,4,16,node5Path16R3);
    
}
else if (room == rm3_0)
{
    //if the first door is unlocked
    if(node1R3.on &amp;&amp; node1CircuitCompleteR3 == false)
    {
        if(objPlayer.atDoor == node1Door)
        {
            node1CircuitCompleteR3 = true;
            node1Door.locked = false;
            node1Door.open = false;
            checkDoor = true;
        }

    }
    if(node1R3.on == false &amp;&amp; node1CircuitCompleteR3)
    {
        if(objPlayer.atDoor == node1Door)
        {
            node1CircuitCompleteR3 = false;
            node1Door.locked = true;
            node1Door.open = true;
            checkDoor = true;
        }
    }
    
    //if the two center doors are unlocked
    if(node1R3.on &amp;&amp; node2R3.on &amp;&amp; node3R3.on &amp;&amp; node4R3.on)
    {
        checkDoor = false;
        
        if(andCircuit1CompleteR3 == false)
        {
            if(objPlayer.atDoor == andDoor1)
            {
                andCircuit1CompleteR3 = true;
                andDoor1.locked = false;
                andDoor1.open = false;
                checkDoor = true;
            }
        }
        
        if(andCircuit2CompleteR3 == false)
        {        
            if(objPlayer.atDoor == andDoor2)
            {
                andCircuit2CompleteR3 = true;
                andDoor2.locked = false;
                andDoor2.open = false;
                checkDoor = true;
            }
        }
    }
    else if(node1R3.on == false || node2R3.on == false || node3R3.on == false || node4R3.on == false)
    {
        if(andCircuit1CompleteR3)
        {
            if(objPlayer.atDoor == andDoor1)
            {
                andCircuit1CompleteR3 = false;
                andDoor1.locked = true;
                andDoor1.open = true;
                checkDoor = true;
            }
        }
        
        if(andCircuit2CompleteR3)
        {
            if(objPlayer.atDoor == andDoor2)
            {
                andCircuit2CompleteR3 = false;
                andDoor2.locked = true;
                andDoor2.open = true;
                checkDoor = true;
            }
        }
    }
    
    if(node5R3.on)
    {
        if(puzzleComplete1 == false)
        {
            if(objPlayer.atDoor == exitDoor1)
            {
                puzzleComplete1 = true;
                exitDoor1.locked = false;
                exitDoor1.open = false;
                checkDoor = true;
            }
        }
        else if(puzzleComplete2 == false)
        {
            if(objPlayer.atDoor == exitDoor2)
            {
                puzzleComplete2 = true;
                exitDoor2.locked = false;
                exitDoor2.open = false;
                checkDoor = true;
            }
        }
    }
    else if(node5R3.on == false)
    {
        if(puzzleComplete1)
        {
            if(objPlayer.atDoor == exitDoor1)
            {
                puzzleComplete1 = false;
                exitDoor1.locked = true;
                exitDoor1.open = true;
                checkDoor = true;
            }
        }
        else if(puzzleComplete2)
        {
            if(objPlayer.atDoor == exitDoor2)
            {
                puzzleComplete2 = false;
                exitDoor2.locked = true;
                exitDoor2.open = true;
                checkDoor = true;
            }
        }
    }
} 

//room 4 creation and solution
if(room == rm4_0 &amp;&amp; puzzleCreated == false) 
{
    ds_grid_clear(puzzleData,0);
    ds_grid_resize(puzzleData,5,12);
    
    puzzleCreated = true;
    
    //puzzle initialization
    puzzleComplete = false;
    node1CircuitCompleteR4 = false;
    node2CircuitCompleteR4 = false;
    node3Circuit1CompleteR4 = false;
    node3Circuit2CompleteR4 = false;
    andNodeCircuitCompleteR4 = false;
    
    //node 1 circiut
    ds_grid_add(puzzleData,0,0,node1R4);
    ds_grid_add(puzzleData,0,1,node1Path1R4);
    ds_grid_add(puzzleData,0,2,node1Path2R4);
    
    //node 2 circiut
    ds_grid_add(puzzleData,1,0,node2R4);
    ds_grid_add(puzzleData,1,1,node2Path1R4);
    ds_grid_add(puzzleData,1,2,node2Path2R4);
    ds_grid_add(puzzleData,1,3,node2Path3R4);
    ds_grid_add(puzzleData,1,4,node2Path4R4);
    ds_grid_add(puzzleData,1,5,node2Path5R4);
    ds_grid_add(puzzleData,1,6,node2Path6R4);
    ds_grid_add(puzzleData,1,7,node2Path7R4);
    
    //node 3 circiut
    ds_grid_add(puzzleData,2,0,node3R4);
    ds_grid_add(puzzleData,2,1,node3Path1R4);
    ds_grid_add(puzzleData,2,2,node3Path2R4);
    ds_grid_add(puzzleData,2,3,node3Path3R4);
    
    //and node 4 circiut
    ds_grid_add(puzzleData,3,0,andNode4R4);
    ds_grid_add(puzzleData,3,1,andNode4Path1R4);
    ds_grid_add(puzzleData,3,2,andNode4Path2R4);
    ds_grid_add(puzzleData,3,3,andNode4Path3R4);
    ds_grid_add(puzzleData,3,4,andNode4Path4R4);
    ds_grid_add(puzzleData,3,5,andNode4Path5R4);
    ds_grid_add(puzzleData,3,6,andNode4Path6R4);
    ds_grid_add(puzzleData,3,7,andNode4Path7R4);
    ds_grid_add(puzzleData,3,8,andNode4Path8R4);
    
    //and node 5 circiut
    ds_grid_add(puzzleData,4,0,andNode5R4);
    ds_grid_add(puzzleData,4,1,andNode5Path1R4);
    ds_grid_add(puzzleData,4,2,andNode5Path2R4);
    ds_grid_add(puzzleData,4,3,andNode5Path3R4);
    ds_grid_add(puzzleData,4,4,andNode5Path4R4);
    ds_grid_add(puzzleData,4,5,andNode5Path5R4);
    ds_grid_add(puzzleData,4,6,andNode5Path6R4);
    ds_grid_add(puzzleData,4,7,andNode5Path7R4);
    ds_grid_add(puzzleData,4,8,andNode5Path8R4);
    ds_grid_add(puzzleData,4,9,andNode5Path9R4);
    ds_grid_add(puzzleData,4,10,andNode5Path10R4);
    ds_grid_add(puzzleData,4,11,andNode5Path11R4);
}
else if(room == rm4_0)
{
     //if the first door is unlocked
    if(node1R4.on &amp;&amp; node1CircuitCompleteR4 == false)
    {
        if(objPlayer.atDoor == door1R4)
        {
            node1CircuitCompleteR4 = true;
            door1R4.locked = false;
            door1R4.open = false;
            checkDoor = true;
        }

    }
    else if(node1R4.on == false &amp;&amp; node1CircuitCompleteR4)
    {
        if(objPlayer.atDoor == door1R4)
        {
            node1CircuitCompleteR4 = false;
            door1R4.locked = true;
            door1R4.open = true;
            checkDoor = true;
        }
    }
    
     //if the second door is unlocked
    if(node2R4.on &amp;&amp; node2CircuitCompleteR4 == false)
    {
        if(objPlayer.atDoor == door2R4)
        {
            node2CircuitCompleteR4 = true;
            door2R4.locked = false;
            door2R4.open = false;
            checkDoor = true;
        }

    }
    else if(node2R4.on == false &amp;&amp; node2CircuitCompleteR4)
    {
        if(objPlayer.atDoor == door2R4)
        {
            node2CircuitCompleteR4 = false;
            door2R4.locked = true;
            door2R4.open = true;
            checkDoor = true;
        }
    }
    
     //if the third and fourth doors are unlocked
    if(node3R4.on)
    {
        if(node3Circuit1CompleteR4 == false)
        {
            if(objPlayer.atDoor == door3R4)
            {
                node3Circuit1CompleteR4 = true;
                door3R4.locked = false;
                door3R4.open = false;
                checkDoor = true;
            }
        }
        else if(node3Circuit2CompleteR4 == false)
        {
            if(objPlayer.atDoor == door4R4)
            {
                node3Circuit2CompleteR4 = true;
                door4R4.locked = false;
                door4R4.open = false;
                checkDoor = true;
            }
        }
    }
    if(node3R4.on == false)
    {
        if(node3Circuit1CompleteR4)
        {
            if(objPlayer.atDoor == door3R4)
            {
                node3Circuit1CompleteR4 = false;
                door3R4.locked = true;
                door3R4.open = true;
                checkDoor = true;
            }
            else if(node3Circuit2CompleteR4)
            {
                if(objPlayer.atDoor == door4R4)
                {
                    node3Circuit2CompleteR4 = false;
                    door4R4.locked = true;
                    door4R4.open = true;
                    checkDoor = true;
                }
            }
        }
    }

    //if the fifth door is unlocked
    if(andNode4R4.on &amp;&amp; andNode5R4.on &amp;&amp; andNodeCircuitCompleteR4 == false)
    {
        if(objPlayer.atDoor == door5R4)
        {
            andNodeCircuitCompleteR4 = true;
            door5R4.locked = false;
            door5R4.open = false;
            checkDoor = true;
        }

    }
    else if((andNode4R4.on == false || andNode5R4.on == false) &amp;&amp; andNodeCircuitCompleteR4)
    {
        if(objPlayer.atDoor == door5R4)
        {
            andNodeCircuitCompleteR4 = false;
            door5R4.locked = true;
            door5R4.open = true;
            checkDoor = true;
        }
    }
    
    if(node1CircuitCompleteR4 &amp;&amp; node2CircuitCompleteR4 &amp;&amp; node3Circuit1CompleteR4 &amp;&amp; node3Circuit2CompleteR4 &amp;&amp; andNodeCircuitCompleteR4 &amp;&amp; puzzleComplete == false)
    {
        if(objPlayer.atDoor == exitDoorR4)
        {
            puzzleComplete = true;
            exitDoorR4.locked = false;
            exitDoorR4.open = false;
            checkDoor = true;
        }
    }
    else if(node1CircuitCompleteR4 == false || node2CircuitCompleteR4 == false || node3Circuit1CompleteR4 == false || node3Circuit1CompleteR4 || andNodeCircuitCompleteR4 = false || puzzleComplete == false)
    {
        if(objPlayer.atDoor == exitDoorR4 &amp;&amp; puzzleComplete)
        {
            puzzleComplete = false;
            exitDoorR4.locked = true;
            exitDoorR4.open = true;
            exitDoorR4 = true;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
